在图（Graph）理论中，深度优先搜索（DFS）和广度优先搜索（BFS）都是基本且常用的遍历算法，但它们各自适用于不同的场景和问题类型。选择哪一种算法取决于你要解决的具体问题和你想从图中获取的信息。以下是DFS和BFS的一些典型用途和特点，可以帮助你根据需求选择合适的算法：

深度优先搜索（DFS）
特点：DFS探索尽可能深的分支，直到到达叶子节点，然后回溯到前一个分叉点，继续探索未访问的分支。
适用场景：
  寻找所有可能的解决方案。
  检查图中是否存在从一点到另一点的路径。
  拓扑排序。
  寻找图中的连通分量。
  解决迷宫和拼图类问题。



广度优先搜索（BFS）
特点：BFS逐层访问图的节点，先访问距离起始点近的节点，再访问距离远的节点。
适用场景：
  寻找最短路径或最少步骤的问题。
  图的层级遍历。
  在无权图中查找从一点到另一点的最短路径。
  广播或遍历网络（如社交网络中的好友关系）。



> BFS   适用于最短类问题(最小，最少)。会用到队列queue[], 同时必须用Set做备忘录，防止重复。
>       每一步就是一层搜索，集体行动
>       BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止。

>双向BFS  使用时必须知道终点是什么。
>         从起点和终点同时开始扩散，当两边有交集的时候停止。

> DFS   适用搜索全部的解，或者必须要走到最深处的问题。
>       会优先访问没有访问过的点，属于 单打独斗
>       不需要保存搜索过程中的状态，空间复杂度低。
>       递归深度 N 最好不要过大.像二维数组的题目，N小于20的，适用DFS。
>       而一般 N<= 200，N<=1000这种，一定不能用DFS去做。会爆栈



综合考虑
图的类型：在稠密图中使用DFS可能更有效，在稀疏图中使用BFS可能更有效。
空间复杂度：DFS通常需要较少的内存，而BFS可能需要更多的内存来存储访问过的节点。
总结
在选择DFS还是BFS时，关键在于理解问题的性质和你想要从图中获取的信息。对于寻找所有可能路径的问题，DFS通常是更好的选择；而对于寻找最短路径的问题，BFS通常是更优的选择。此外，还需要考虑图的特性（如大小、密度）和算法的空间复杂度。



```python
BFS

def BFS(start, target):
    if start is None:  # 判断初始条件，特殊情况直接return
        return None

    queue = []  # 核心数据结构
    visited = set()  # 避免走回头路

    queue.append(start)  # 将起点加入队列
    visited.add(start)  # 像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要visited
    step = 0  # 记录扩散的步数

    while queue:
        size = len(queue)
        # 将当前队列中的所有节点向四周扩散
        for i in range(size):
            cur = queue.pop(0)
            if cur == target:  # 划重点：这里判断是否到达终点
                return step
            # 将 cur 的相邻节点加入队列
            for x in cur.adj():  # cur.adj()泛指 cur 相邻的节点
                if x not in visited:
                    queue.append(x)
                    visited.add(x)
        # 划重点：更新步数在这里
        step += 1

    return None  # 如果没有找到目标，返回 None

```